# Устранение проблем с Telegram ботом

## Проблема: Конфликт экземпляров бота

### Описание ошибки
```
TelegramConflictError: Telegram server says - Conflict: terminated by other getUpdates request; make sure that only one bot instance is running
```

Эта ошибка возникает когда:
- Уже запущен другой экземпляр бота с тем же токеном
- Предыдущий экземпляр не был корректно завершен
- Бот запущен в нескольких местах одновременно

## Решения

### 1. Рекомендований спосіб (використання скрипта)

Якщо при запуску `main.py` ви бачите помилку `TelegramConflictError` або попередження, що бот вже запущений, це означає, що інший екземпляр бота вже працює (або залишився "завислий" процес).

Щоб це виправити, запустіть спеціальний скрипт-менеджер для примусової зупинки всіх "завислих" процесів:
```bash
python bot_manager.py stop
```

### 2. Быстрая остановка ⚡ НОВОЕ

Для мгновенной остановки всех экземпляров бота:

```bash
python quick_stop.py
```

Или используйте менеджер напрямую:
```bash
python bot_manager.py stop
```

### 3. Принудительная остановка (старый метод)

Если нужен старый метод остановки:

```bash
python stop_bot.py
```

### 3. Ручная остановка

#### Windows:
```cmd
# Найти процессы Python
tasklist | findstr python.exe

# Завершить все процессы Python (осторожно!)
taskkill /F /IM python.exe

# Или завершить конкретный процесс по PID
taskkill /F /PID <PID>
```

#### Linux/macOS:
```bash
# Найти процессы с main.py
ps aux | grep main.py

# Завершить процесс по PID
kill -TERM <PID>

# Или принудительно
kill -KILL <PID>

# Найти и завершить все процессы с main.py
pkill -f main.py
```

### 4. Проверка webhook

Иногда проблема связана с установленным webhook. Проверьте и удалите его:

```python
import asyncio
from aiogram import Bot
from config.config import TOKEN

async def check_webhook():
    bot = Bot(TOKEN)
    info = await bot.get_webhook_info()
    print(f"Webhook URL: {info.url}")
    print(f"Pending updates: {info.pending_update_count}")
    
    if info.url:
        await bot.delete_webhook(drop_pending_updates=True)
        print("Webhook удален")
    
    await bot.session.close()

asyncio.run(check_webhook())
```

## Предотвращение проблем

### 1. Корректное завершение
Всегда завершайте бота через `Ctrl+C` или соответствующий сигнал. Не закрывайте терминал принудительно.

### 2. Один экземпляр
Убедитесь, что запущен только один экземпляр бота:
- Не запускайте бота в нескольких терминалах
- Не запускайте на разных серверах с одним токеном
- Проверяйте фоновые процессы

### 3. Использование виртуального окружения
```bash
# Активация виртуального окружения
source venv/bin/activate  # Linux/macOS
# или
venv\Scripts\activate     # Windows

# Запуск бота
python main.py
```

### 4. Мониторинг процессов
Используйте системные инструменты для мониторинга:
- Task Manager (Windows)
- Activity Monitor (macOS)
- htop/ps (Linux)

## Логи и отладка

### Уровни логирования
В `main.py` настроен уровень `INFO`. Для более детальной отладки измените на `DEBUG`:

```python
logging.basicConfig(
    level=logging.DEBUG,  # Изменить здесь
    format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
)
```

### Полезные логи
Обращайте внимание на сообщения:
- `Знайдено бота: ...` - бот найден и токен корректный
- `Webhook видалено` - webhook успешно удален
- `Конфлікт з іншим екземпляром` - обнаружен конфликт
- `Polling зупинено` - polling корректно остановлен

## Часто задаваемые вопросы

### Q: Бот не запускается даже после остановки
A: Подождите 30-60 секунд после остановки, затем попробуйте снова. Telegram серверу нужно время для обработки изменений.

### Q: Ошибка повторяется постоянно
A: Проверьте, не запущен ли бот где-то еще (другой сервер, другой терминал, фоновый процесс).

### Q: Скрипт остановки не работает
A: Попробуйте ручную остановку процессов или перезагрузите систему.

### Q: Бот работал, но внезапно появилась ошибка
A: Возможно, произошел сбой сети или перезапуск системы. Используйте скрипт остановки и запустите заново.

## Новые файлы системы

### bot_manager.py
Основной менеджер для управления экземплярами бота:
- Класс `BotManager` для контроля единственности экземпляра
- Функция `safe_bot_start()` для безопасного запуска
- Функция `force_stop_bot()` для принудительной остановки
- Автоматическое управление файлами блокировки

### quick_stop.py
Простой скрипт для быстрой остановки бота:
- Использует функции из `bot_manager.py`
- Минимальный интерфейс для пользователя
- Обработка ошибок импорта

### Файлы блокировки
Система создает временные файлы для контроля:
- `bot.lock` - файл блокировки с PID текущего процесса
- `bot.pid` - файл с идентификатором процесса бота

Эти файлы автоматически удаляются при корректном завершении работы.

## Миграция с старой системы

Если вы обновляете существующий проект:

1. **Установите зависимость psutil** (если еще не установлена):
   ```bash
   pip install psutil
   ```

2. **Новые файлы уже добавлены**:
   - `bot_manager.py` - менеджер бота
   - `quick_stop.py` - скрипт быстрой остановки
   - Обновленный `main.py` - использует новый менеджер

3. **Старые методы остаются доступными**:
   - `stop_bot.py` - по-прежнему работает
   - Ручная остановка процессов - как резервный вариант

4. **Рекомендуемый порядок действий**:
   ```bash
   # Остановите текущий бот любым способом
   python quick_stop.py
   
   # Запустите с новой системой
   python main.py
   ```

## Контакты для поддержки

Если проблема не решается:
1. Проверьте логи на предмет других ошибок
2. Убедитесь, что токен бота корректный
3. Проверьте подключение к интернету
4. Убедитесь, что установлена библиотека `psutil`
5. Обратитесь к администратору бота
